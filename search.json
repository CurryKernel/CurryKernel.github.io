[{"title":"华为校招笔试0424","url":"/2024/04/25/华为校招笔试0424/","content":"## 第一题 满二叉搜索树查找\n给定2<sup>n</sup> - 1个不同的整数(1 &le; n &le; 10，n为整数),构建一棵平衡满二叉搜索树\n二叉搜索树定义如下:\n\n1. 节点的左子树只包含小于当前节点的数。\n2. 节点的右子树只包含大于当前节点的数。\n3. 所有左子树和右子树自身必须也是二叉搜索树。\n<!-- 在需要阶段的地方加入下面这句，或者加入description: 这是显示在首页的概述，正文内容均会被隐藏。 -->\n<!--more--> \n例如 7个数字 '1234567' 构建的满二叉搜索树如下所示\n```\n      4\n   2     6\n  1 3   5 7\n```\n**输入**\n\n    输入分2行, 第一行为2^n-1个未排序的整数，空格分隔,用于构建二叉搜索树,其中1<=n<=10，第二行为待查找的整数。所有输入整数的取值范围为[-32768，32767]。\n**输出**\n\n    搜索的路径和结果 路径从根节点开始,用S表示,查找左树用L表示，查找右树使用R表示，找到后使用Y表示，最终未找到使用N表示。\n**样例**\n    \n    样例1：\n    输入：\n    2 1 3 7 5 6 4\n    6\n    输出\n    SRY\n    解释：从根节点开始，所以路径的第一部分为S，待查找数为6，大于4，所以要查找右树，路径增加R,正好找到。所以最后增加Y,最终输出SRY\n    样例2：\n    输入：\n    4 2 1 3 6 5 7\n    5\n    输出：\n    SRLY\n    解释：从根节点开始,一次往右树,往左树查找,找到结果5,因此最终SRLY\n    样例3：\n    输入：\n    1 2 3 4 5 6 7\n    8\n    输出：\n    SRRN\n    解释:从根节点开始查找，标记s，待查找数8比4大,所以查找右树，标记R, 8比6还大，继续查找右树标记R，8比右树节点7还大,但已经到了叶子,没有找到,因此最终标记SRRN\n\n**思路和代码**\n\n本质就是一个二叉搜索树的遍历，不过我们不用建立二叉树，可以用二分查找来代替，需要注意的是，访问到叶子节点后，如果还没有找到，此时并不增加路径。\n\n**代码逻辑解释**\n1. **输入数据**：\n   - 使用 `getline(cin, s)` 从输入中读取一行字符串，这一行包含了 `2^n - 1` 个未排序的整数。\n   - 通过 `stringstream` 和 `while` 循环，将这些字符串形式的整数转换为实际的整数，并存储在向量 `v` 中。\n   - 然后从第二行输入中读取一个目标整数 `target`。\n\n2. **构建平衡满二叉搜索树**：\n   - 平衡满二叉搜索树要求所有节点的左右子树是平衡的。对于给定的整数集合，这种树结构可以通过排序后取中间值作为根节点，然后递归地在左右子树中重复这个过程来实现。\n   - 在这段代码中，使用 `sort(v.begin(), v.end())` 将输入的整数按升序排序。\n\n3. **二叉搜索树中的搜索**：\n   - 通过二分查找在 BST 中搜索目标 `target`。二分查找的方式可以自然模拟 BST 的搜索过程。\n   - 设置 `l` 为左边界，`r` 为右边界，通过 `while (l <= r)` 循环执行搜索：\n     - `m` 是当前中间位置 (`m = (l + r) / 2`)。\n     - 如果 `v[m]` 与目标 `target` 相等，路径 `ans` 加上 `Y`，表示找到目标，跳出循环。\n     - 如果 `v[m]` 大于目标，路径 `ans` 加上 `L`，表示向左子树搜索，调整右边界 `r = m - 1`。\n     - 如果 `v[m]` 小于目标，路径 `ans` 加上 `R`，表示向右子树搜索，调整左边界 `l = m + 1`。\n\n4. **结果处理**：\n   - 若搜索路径的最后一个字符不是 `Y`，则添加 `N`，表示未找到目标。\n   - 输出搜索路径。\n\n**代码**\n```cpp\n        #include <sstream>\n        #include <iostream>\n        #include <string>\n        #include <vector>\n        #include <algorithm>\n        using namespace std;\n\n        vector<int> v;\n        int target;\n\n        int main()\n        {\n            stringstream ss;\n            string s, t;\n            getline(cin, s);\n            ss << s;\n            v.clear();\n            while (ss >> t) {\n                v.push_back(stoi(t));\n            }\n        // getchar();\n            cin >> target;\n            sort(v.begin(), v.end());\n            string ans = \"S\";\n            int l = 0, r = v.size() - 1;\n            int d = 0;\n            while (l <= r) {\n                int m = (l + r) / 2;\n                d++;\n                if (v[m] == target) { ans += \"Y\"; break; }\n                if (v[m] > target) {\n                    if ((1 << (d)) > v.size()) break;\n                    ans += \"L\"; r = m - 1;\n                } else {\n                    if ((1 << (d)) > v.size()) break;\n                    ans += \"R\"; l = m + 1;\n                }\n            }\n            if (ans.back() != 'Y') ans += \"N\";\n            cout << ans;\n            return 0;\n        }\n```\n***\n## 第二题 足球队员射门能力排序\n球队有`n`个足球队员参与`m`次射门训练，每次射门进球用1表示，射失则用0表示，依据如下规则对该`n`个队员的射门能力做排序 1、进球总数更多的队员射门能力更强 2、若进球总数—样多，则比较最多—次连续进球的个数，最多的队员能力更强 3、若最多一次连续进球的个数一样多，则比较第一次射失的先后顺序，其中后射失的队员更强，若第一次射失顺序相同，则按继续比较第二次射失的顺序，后丢球的队员能术更强，依次类推 4、若前3个规则排序后还能力相等，则队员编号更小的能力更强\n\n**输入**\n\n    第1行，足球队员数n，射门训练次数m。(队员编号从1开始，依次递增) 第2行，第1~n个队员从第1到m次训练的进球情况，每个队员进球情况为连续的1和0的组合，不同队员用空格分隔n和m均为正整数。\n**输出**\n\n    射门能力从强到弱的队员编号,用空格分隔    \n\n**注意：0 &lt; n &le; 10<sup>3</sup>, 0 &lt; m &le; 10<sup>3</sup>**\n\n**样例**\n\n    输入：\n    4 5\n    11100 0011110111 01111\n    输出：\n    4 3 1 2\n    解释：4个队员，射门训练5次，队员3和4进球数均为4个，比队员1和2的3个更多,队员3连续进球数最多一次为3个,而队员4最大为4，因此队员4射门能力强于队员3,另外队员2比队员1先丢球，因此队员1射门能力强于队员2，排序为4312\n    输入：\n    2 10\n    1011100111 1011101101\n    输出：\n    2 1\n    解释：2个队员，射门训练10次，两个队员的进球总数均为7个,连续进球最多的均为3个，且第前两次丢球顺序均为第二次和第6次训练射门，而队员2第三次丢球为第9次训练,队员2为第7次训练，因此队员2的射门能力强于队员1,排序为21\n\n**思路和代码**\n本质就是一个排序问题，但是排序的规则比较复杂，需要预处理数据，得到每个人的进球数、最多的连续进球个数、失球顺序，然后排序的时候按照题目要求进行返回即可。\n\n**代码逻辑解释**\n\n这段代码根据特定的规则对一组足球队员的射门能力进行排序。排序规则包括进球总数、最长连续进球数、第一次射失顺序等。\n\n1. **输入数据**：\n   - 首先读取 `n` 和 `m`，表示足球队员数量和射门训练次数。\n   - 创建向量 `goals` 和 `seq`，分别记录每个队员的进球总数和最长连续进球数。\n   - `fs` 用于记录每个队员的射失位置。\n\n2. **计算队员的进球总数、最长连续进球数、射失顺序**：\n   - 遍历每个队员，读取其射门结果字符串 `s`。\n   - 使用 `g` 统计进球总数，用 `cur_s` 统计当前连续进球数，`mx_s` 记录最长连续进球数。\n   - 遍历射门结果 `s`，如果进球 (即 `s[j] == '1'`)，则增加 `cur_s`；否则，记录射失位置并重置 `cur_s`。\n   - 将 `fs[i]` 记录每个队员的射失位置。\n   - 更新 `goals[i]` 为 `g`，`seq[i]` 为 `mx_s`。\n\n3. **对队员进行排序**：\n   - 创建 `idx` 向量，用于存储队员的索引。\n   - 按照给定的排序规则对 `idx` 进行排序：\n     1. **进球总数**：如果 `goals[a]` 大于 `goals[b]`，则 `a` 能力更强，反之亦然。\n     2. **最长连续进球数**：如果 `seq[a]` 大于 `seq[b]`，则 `a` 能力更强，反之亦然。\n     3. **射失顺序**：对 `fs[a]` 和 `fs[b]` 中的射失位置进行比较，如果 `fs[a][j]` 大于 `fs[b][j]`，则 `a` 更强，反之亦然。\n     4. **队员编号**：如果以上都相同，按编号从小到大排序。\n\n4. **输出排序后的队员编号**：\n   - 遍历排序后的 `idx` 向量，输出对应的队员编号。\n   - 队员编号从 1 开始，所以输出 `idx[i] + 1`。\n   - 在输出时用空格分隔，如果是最后一个元素，则不输出空格。\n\n```cpp\n        #include <sstream>\n        #include <iostream>\n        #include <string>\n        #include <vector>\n        #include <algorithm>\n        using namespace std;\n\n        int main()\n        {\n            int n, m; cin >> n >> m;\n            vector<int> goals(n, 0), seq(n, 0);\n            vector<vector<int>> fs(n);\n            for (int i = 0; i < n; ++i) {\n                string s; cin >> s;\n                int g = 0, mx_s = 0, cur_s = 0;\n                for (int j = 0; j < m; ++j) {\n                    g += (s[j] == '1');\n                    if (s[j] == '1') ++cur_s;\n                    else {\n                        fs[i].push_back(j);\n                        mx_s = max(mx_s, cur_s); cur_s = 0;\n                    }\n                }\n                goals[i] = g; seq[i] = max(mx_s, cur_s);\n            }\n            vector<int> idx(n);\n            for (int i = 0; i < n; ++i) idx[i] = i;\n            sort(idx.begin(), idx.end(), [&](auto& a, auto& b) {\n                // 进球数\n            if (goals[a] > goals[b]) return true;\n            if (goals[a] < goals[b]) return false;\n                // 最多连续进球数\n            if (seq[a] > seq[b]) return true;\n            if (seq[a] < seq[b]) return false;\n                // 射失顺序\n            int sz = fs[a].size();\n            for (int j = 0; j < sz; ++j) {\n                if (fs[a][j] > fs[b][j]) return true;\n                if (fs[a][j] < fs[b][j]) return false;\n            }\n                return a < b;\n            });\n            for (int i = 0; i < n; ++i) {\n                cout << idx[i] + 1;\n                if (i != n - 1) cout << \" \";\n            }\n            return 0;\n        }\n```\n***\n## 第三题 找到内聚值最大的微服务群组\n\n开发团队为了调研微服务调用情况,对`n`个微服务调用数据进行了采集分析,微服务使用数字`0`至`n-1`进行编号，给你一个下标从`0`开始的数组`edges` , 其中`edges[i]`表示存在一条从微服务`i`到微服务`edges[i]`的接口调用。\n\n我们将形成`1`个环的多个微服务称为微服务群组，一个微服务群组的所有微服务数量为`L`，能够访问到该微服务群组的微服务数量为`V`,这个微服务群组的内聚值`H=L-V`。\n\n已知提供的数据中有`1`个或多个微服务群组，请按照内聚值`H`的结果从大到小的顺序对所有微服务群组(`H`相等时，取环中最大的数进行比较)排序，输出排在第一的做服务群组，输出时每个微服务群组输出的起始编号为环中最小的数。\n\n**输入**\n\n分为两行输入: 第一行为`n`,表示有`n`个微服务 第二行为数组`edges`,其中`edges[i]`表示存在一条从微服务`i`到微服务`edges[i]`的接口调用，数字以空格分隔\n输入范围说明: **n == edges.length, 2 &le; n <= 10<sup>5</sup>, 0 &le; edges[i] &le; n-1, edges[i] !=i**\n\n**输出**\n\n输出排在第一的微服务群组的编号数组，按照环的访问顺序输出，起始编号为环中最小的数,数字以空格分隔\n\n**样例**\n\n    输入：\n    4\n    3 3 0 1\n    输出：\n    0 3 2\n    输入：\n    12\n    2 6 10 1 6 0 3 0 5 4 5 8\n    输出：\n    0 2 10 5\n\n**思路和代码**\n\n题意解释：\n\n- 微服务调用：给定 `n` 个微服务，通过 `edges` 数组表示微服务之间的调用关系，其中 `edges[i]` 表示从微服务 `i` 调用微服务 `edges[i]`。\n- 环：如果一个微服务通过一系列调用最终又回到自己，说明它处于一个环中。\n- 内聚值：设微服务环中的节点数为 `L`，可直接访问到该环的节点数为 `V`，则内聚值 `H = L - V`。根据题意，要找到内聚值最大的微服务环。\n\n代码逻辑：\n1. 输入数据：\n   - 从输入中读取 `n` 表示微服务数量。\n   - 创建 `edges` 数组，保存每个微服务的调用目标。\n   - 创建 `in` 数组，记录每个节点的入度（即有多少其他节点指向这个节点）。\n\n2. 找到出度为零的节点并删除：\n   - 使用 `queue` 队列，记录所有出度为零的节点，并逐步处理，以删除不在环内的节点。\n   - 对于 `in[i] == 0` 的节点，添加到队列，并减少相应的 `in` 值，表示它不再影响其他节点。\n\n3. 确定微服务环和内聚值：\n   - `cir` 是用于存储所有环的向量。\n   - `value` 记录内聚值。\n   - `mx` 记录每个环中最大的节点编号。\n   - 遍历 `in` 数组，找到环并计算内聚值：\n     - 对于每个 `in[i] > 0` 的节点（环的开始），使用 `path` 保存环中的所有节点，并将入度设为 0。\n     - `v` 是到环前经过的节点数。\n     - `mx_no` 记录当前环中的最大节点编号。\n   - 计算内聚值 `value` 为环的节点数 `L` 减去访问环的节点数 `V`。\n\n4. 排序环并输出结果：\n   - `idx` 是一个索引数组，用于按照内聚值和最大节点编号排序。\n   - 对 `idx` 数组排序：\n     - 如果内聚值相等，则按照最大节点编号降序排序。\n   - 找到排序后内聚值最大的环，并确定其起始编号为最小节点。\n   - 输出环中所有节点，按照环的访问顺序，从最小节点开始，输出结果。\n\n环的查找(找到内聚值最大的微服务组)：\n1. **初始化**\n   - `cir` 是一个二维数组，用于存储找到的所有环。\n   - `value` 是一维数组，存储每个环的内聚值。\n   - `mx` 是一维数组，记录每个环中最大的节点编号。\n\n2. **查找环**\n   - 遍历所有节点，如果 `in[i] > 0`，这表示该节点可能在一个环中。\n   - 如果这个节点可能属于环：\n     - 创建一个 `path` 数组，存储环中的节点。\n     - 将 `in[c]` 置零，表示这个节点已被处理。\n   - `v` 变量用于记录在进入环之前访问到的节点数量。\n   - `mx_no` 用于记录当前环中最大的节点编号。\n   - 通过 `edges` 数组跟踪下一个节点，直到环形成并返回到起点。\n   - 每次找到一个环节点时：\n     - 将其添加到 `path` 中。\n     - 更新 `v` 的值（因为环之前访问的节点数量会增加）。\n     - 检查是否是新的最大节点，并更新 `mx_no`。\n\n3. **计算内聚值**：\n   - 对于找到的环，`path` 保存了环中的所有节点。\n   - 环的大小 `L` 为 `path.size()`。\n   - 内聚值 `H = L - V`，其中 `V` 是在进入环之前访问到的节点数量。\n   - 将计算的内聚值 `H` 添加到 `value` 数组，将 `path` 添加到 `cir` 数组，将最大节点编号 `mx_no` 添加到 `mx` 数组。\n  \n```cpp\n        #include <sstream>\n        #include <iostream>\n        #include <string>\n        #include <vector>\n        #include <algorithm>\n        #include <queue>\n        using namespace std;\n        int n; \n\n        int main()\n        {\n            cin >> n;\n            vector<int> edges(n);\n            vector<int> in(n, 0);\n            // 每个节点的子节点数目\n            vector<int> nums(n, 0);\n            for (int i = 0; i < n; ++i) {\n                cin >> edges[i];\n                in[edges[i]]++;\n            }\n            queue<int> q;\n            for (int i = 0; i < n; ++i) {\n                if (in[i] == 0) q.push(i);\n            }\n            while (!q.empty()) {\n                int sz = q.size();\n                while (sz--) {\n                    int f = q.front(); q.pop();\n                    in[edges[f]]--;\n                    nums[edges[f]] += nums[f] + 1;\n                    if (in[edges[f]] == 0) {\n                        q.push(edges[f]);\n                    }\n                }\n            }\n            vector<vector<int>> cir;\n            vector<int> value;\n            vector<int> mx;\n            for (int i = 0; i < n; ++i) {\n                if (in[i] == 0) continue;\n                int c = i, v = 0, mx_no = i;\n                vector<int> path; \n                while (in[c]) {\n                    v += nums[c];\n                    path.push_back(c); in[c] = 0;\n                    c = edges[c];\n                    mx_no = max(mx_no, c);\n                }\n                cir.push_back(path);\n                mx.push_back(mx_no);\n                value.push_back(path.size() - v);\n            }\n            vector<int> idx(value.size());\n            for (int i = 0; i < value.size(); ++i) idx[i] = i;\n            sort(idx.begin(), idx.end(), [&](auto& a, auto& b) {\n            return value[a] == value[b] ? mx[a] > mx[b] : value[a] > value[b]; \n            });\n            auto& path = cir[idx[0]];\n            int start = *min_element(path.begin(), path.end());\n            for (int i = 0; i < path.size(); ++i) {\n                cout << start;\n                start = edges[start];\n                if (i != path.size() - 1) cout << \" \";\n            }\n            return 0;\n        }\n```","tags":["校招","华为"],"categories":["算法题"]}]